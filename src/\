#include "ke_shapes.h"
#include "ke_math.h"
#include <math.h>
#include <stdio.h>
#include <string.h>

shape* generate_triangle(vec3 color){
   
    int vertex_count = 3;
    int index_count = 3;
    //size_t size = sizeof(int) * index_count + sizeof(float) * vertex_count * 8;
    float triangle_vertices[] = {
        -1.0f, -1.0f, 0, color.x, color.y, color.z, -1.0f, -1.0f,
         1.0f, -1.0f, 0, color.x, color.y, color.z,  1.0f, -1.0f,
         0.5f,  1.0f, 0, color.x, color.y, color.z,  0.5f,  1.0f
    };
   
    int triangle_indices[] = {
        0, 1, 2
    };

    shape* triangle = malloc(sizeof(shape));
    triangle->vertices = (float*)malloc(sizeof(float) * vertex_count * 8);
    triangle->indices = (int*)malloc(sizeof(int) * index_count);

    for (int i = 0; i < vertex_count * 8; i++){
        triangle->vertices[i] = triangle_vertices[i];
    }
   
    for (int i = 0; i < index_count; i++){
        triangle->indices[i] = triangle_indices[i];
    }

    return triangle;
}

shape* generate_square(vec3 color){

    shape* square;
   
    int vertex_count = 4;
    int index_count = 6;
    size_t size = sizeof(int) * index_count + sizeof(float) * vertex_count * 8;
    square = malloc(size);

    float square_vertices[] = {
        -1.0f, -1.0f, 0, color.x, color.y, color.z, -1.0f, -1.0f,
         1.0f, -1.0f, 0, color.x, color.y, color.z,  1.0f, -1.0f,
         1.0f,  1.0f, 0, color.x, color.y, color.z,  1.0f,  1.0f,
        -1.0f,  1.0f, 0, color.x, color.y, color.z, -1.0f,  1.0f
    };
   
    int square_indices[] = {
        0, 1, 3, 1, 2, 3
    };

    for (int i = 0; i < vertex_count; i++){
        square->vertices[i] = square_vertices[i];
    }
   
    for (int i = 0; i < index_count; i++){
        square->indices[i] = square_indices[i];
    }

    return square;
}

//
//
//disc* generate_disc(vec3 color, int slices){
//
//    disc* disc;
//    
//    for (int i = 0; i < slices; i++){
//        disc->vertices[i].x = cosf(i * 2  * PI / slices);
//        disc->vertices[i].y = sinf(i * 2  * PI / slices);
//        disc->vertices[i].z = 0;
//        disc->vertices[i].r = color.x;
//        disc->vertices[i].g = color.y;
//        disc->vertices[i].b = color.z;
//        disc->vertices[i].u = cosf(i * 2  * PI / slices);
//        disc->vertices[i].v = sinf(i * 2  * PI / slices);
//    }
//
//    for (int i = 0; i < slices; i++){
//        disc->indices[i * 3 + 0] = 0;
//        disc->indices[i * 3 + 1] = i + 1;
//        disc->indices[i * 3 + 2] = i + 2;
//    }
//
//    return disc;
//}

//cube* generate_cube(vec3 color){
//
//    cube* cube;
//    
//    cube = generate_square(color);
//    memcpy(cube->vertices + 4, cube->vertices, sizeof(vertex) * 4);
//    for (int i = 0; i < 4; i++){
//        cube->vertices[i].z = -1.0f;
//    }
//    for (int i = 4; i < 8; i++){
//        cube->vertices[i].z = 1.0f;
//    }
//
//    int indices[] = {
//        0, 1 , 3,  1, 2 , 3,
//        4, 5 , 7,  5, 6 , 7,
//        0, 4 , 1,  1, 5 , 4,
//        2, 6 , 3,  3, 7 , 6,
//        0, 2 , 4,  4, 6 , 2,
//        1, 3 , 5,  5, 7 , 3,
//    };
//
//    for (int i = 0; i < 36; i++){
//        cube->indices[i] = indices[i];
//    }
//
//    return cube;
//        
//}
